#version 440

#define M_PI 3.1415926535897932384626433832795
#define NUM_BUTTERFLIES 1
#define FFT_SIZE 512
#define LOG_SIZE 9 // log2(FFT_SIZE)
#define HALF_LOG_SIZE 4 // log2(FFT_SIZE) / 2

layout (local_size_x = (FFT_SIZE/4)/NUM_BUTTERFLIES, local_size_y = 1) in;

// ping pong textures
layout (binding = 0, rg32f) uniform image2D pingpong0;
layout (binding = 1, rg32f) uniform image2D pingpong1;

uniform int fft_dir;

vec2 complex_mult(vec2 v0, vec2 v1) {
    return vec2(v0.x * v1.x - v0.y * v1.y,
                v0.x * v1.y + v0.y * v1.x);
}


vec2 euler(float angle) {
    return vec2(cos(angle), sin(angle));
}


void main() {
    int line = int(gl_GlobalInvocationID.x);
    int column = int(gl_WorkGroupID.y);
    int pingpong = 0;

    for(int stage = 0; stage < HALF_LOG_SIZE; ++stage) {
        // Each iteration on this loop corresponds
        // to a stage iteration on each reserved positions
        // for this thread

        // 1. Compute Butterflies
        int n = 1 << ((HALF_LOG_SIZE - stage)*2 + 1);
        int s = 1 << (stage*2);

        int n0 = 0;
        int n1 = n/4;
        int n2 = n/2;
        int n3 = n1 + n2; // 3N/4

        for(int i = 0; i < NUM_BUTTERFLIES; ++i) {
            int idx = (line*NUM_BUTTERFLIES + i);
            // Compute p and q
            int p = idx / s;
            int q = idx % s;
            // Compute the twiddle factors
            vec2 w1p = euler(2*(M_PI / n) * p * fft_dir);
            vec2 w2p = complex_mult(w1p,w1p);
            vec2 w3p = complex_mult(w1p,w2p);

            if(pingpong == 0) {
                // Compute natural order butterflies
                vec2 a = imageLoad(pingpong0, ivec2(q + s*(p + n0), column)).rg;
                vec2 b = imageLoad(pingpong0, ivec2(q + s*(p + n1), column)).rg;
                vec2 c = imageLoad(pingpong0, ivec2(q + s*(p + n2), column)).rg;
                vec2 d = imageLoad(pingpong0, ivec2(q + s*(p + n3), column)).rg;

                vec2 apc = a + c;
                vec2 amc = a - c;
                vec2 bpd = b + d;
                vec2 jbmd = complex_mult(vec2(0,1), b - d);

                imageStore(pingpong1, ivec2(q + s*(4*p + 0), column), vec4(apc + bpd, 0,0));
                imageStore(pingpong1, ivec2(q + s*(4*p + 1), column), vec4(complex_mult(w1p, amc + jbmd*fft_dir), 0,0));
                imageStore(pingpong1, ivec2(q + s*(4*p + 2), column), vec4(complex_mult(w2p, apc - bpd ), 0,0));
                imageStore(pingpong1, ivec2(q + s*(4*p + 3), column), vec4(complex_mult(w3p, amc - jbmd*fft_dir), 0,0));
            }
            else {
                // Compute natural order butterflies
                vec2 a = imageLoad(pingpong1, ivec2(q + s*(p + n0), column)).rg;
                vec2 b = imageLoad(pingpong1, ivec2(q + s*(p + n1), column)).rg;
                vec2 c = imageLoad(pingpong1, ivec2(q + s*(p + n2), column)).rg;
                vec2 d = imageLoad(pingpong1, ivec2(q + s*(p + n3), column)).rg;

                vec2 apc = a + c;
                vec2 amc = a - c;
                vec2 bpd = b + d;
                vec2 jbmd = complex_mult(vec2(0,1), b - d);

                imageStore(pingpong0, ivec2(q + s*(4*p + 0), column), vec4(apc + bpd, 0,0));
                imageStore(pingpong0, ivec2(q + s*(4*p + 1), column), vec4(complex_mult(w1p, amc + jbmd*fft_dir), 0,0));
                imageStore(pingpong0, ivec2(q + s*(4*p + 2), column), vec4(complex_mult(w2p, apc - bpd ), 0,0));
                imageStore(pingpong0, ivec2(q + s*(4*p + 3), column), vec4(complex_mult(w3p, amc - jbmd*fft_dir), 0,0));
            }
        }

        // 2. Update Variables
        pingpong = (pingpong + 1) % 2;

        // 3. Sync by Memory Barrier
        barrier();
    }

    // Final stage as radix-2
    if(LOG_SIZE % 2 == 1) {
        int s = FFT_SIZE >> 1;
        int q = 2*line;

        if(pingpong == 0) {
            vec2 a = imageLoad(pingpong0, ivec2(q + 0, column)).rg;
            vec2 b = imageLoad(pingpong0, ivec2(q + s, column)).rg;

            imageStore(pingpong1, ivec2(q + 0, column), vec4(a + b, 0,0));
            imageStore(pingpong1, ivec2(q + s, column), vec4(a - b, 0,0));

            // There's only SIZE/4 local threads therefore we compute 2 values
            q = 2*line + 1;

            a = imageLoad(pingpong0, ivec2(q + 0, column)).rg;
            b = imageLoad(pingpong0, ivec2(q + s, column)).rg;

            imageStore(pingpong1, ivec2(q + 0, column), vec4(a + b, 0,0));
            imageStore(pingpong1, ivec2(q + s, column), vec4(a - b, 0,0));
        }
        else {
            vec2 a = imageLoad(pingpong1, ivec2(q + 0, column)).rg;
            vec2 b = imageLoad(pingpong1, ivec2(q + s, column)).rg;

            imageStore(pingpong0, ivec2(q + 0, column), vec4(a + b, 0,0));
            imageStore(pingpong0, ivec2(q + s, column), vec4(a - b, 0,0));

            // There's only SIZE/4 local threads therefore we compute 2 values
            q = 2*line + 1;

            a = imageLoad(pingpong1, ivec2(q + 0, column)).rg;
            b = imageLoad(pingpong1, ivec2(q + s, column)).rg;

            imageStore(pingpong0, ivec2(q + 0, column), vec4(a + b, 0,0));
            imageStore(pingpong0, ivec2(q + s, column), vec4(a - b, 0,0));
        }
    }
}