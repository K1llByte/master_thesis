#version 430

#define M_PI 3.1415926535897932384626433832795

layout (local_size_x = 8, local_size_y = 4) in;


// ping pong textures
layout (binding = 0, rg32f) uniform image2D pingpong0;
layout (binding = 1, rg32f) uniform image2D pingpong1;

uniform int pingpong;
uniform int log_width;
uniform int stage;
uniform int fft_dir;

// Constants
/* const  */
int vals_per_processors = 256 / 8;
int iter = 1 << log_width;
int shift = (1 << stage);

vec2 complex_mult(vec2 v0, vec2 v1) {
    return vec2(
        v0.x * v1.x - v0.y * v1.y,
        v0.x * v1.y + v0.y * v1.x
    );
}

int bit_reverse(int k) {
    uint x = uint(k);
    uint n = 0;
    uint mask = 0x1;
    for (int i = 0; i < log_width; ++i) {
        n <<= 1;
        n |= (x & 1);
        x >>= 1;
    }
    return int(n);
}

vec2 euler(float angle) {
    return vec2(cos(angle), sin(angle));
}


void main() {
    uint line = gl_GlobalInvocationID.x;
    uint column = gl_GlobalInvocationID.y;

    int group_size = 2 << stage;
    int half_group_size = group_size >> 1;
    int k = int(line) % half_group_size;
    int idx = int(line)*vals_per_processors + k;

    // Compute the twiddle factor
    vec2 w = euler(fft_dir * 2 * k * M_PI / group_size);

    vec2 elemk, elemks;
    // Alternate between textures
    if(pingpong == 0)
    {
        vec2 result;
        if((idx % group_size) >= half_group_size) {
            if(stage == 0) {
                // when stage = 0 use bit reverse indices
                elemk = imageLoad(pingpong0, ivec2(bit_reverse(idx), column)).rg;
                elemks = imageLoad(pingpong0, ivec2(bit_reverse(idx-half_group_size), column)).rg;
            }
            else {
                elemk = imageLoad(pingpong0, ivec2(idx, column)).rg;
                elemks = imageLoad(pingpong0, ivec2(idx-half_group_size, column)).rg;
            }
            result = elemks - complex_mult(w, elemk);
            imageStore(pingpong1, ivec2(idx, column), vec4(result,0,0));
        }
        else {
            if(stage == 0) {
                // when stage = 0 use bit reverse indices
                elemk = imageLoad(pingpong0, ivec2(bit_reverse(idx), column)).rg;
                elemks = imageLoad(pingpong0, ivec2(bit_reverse(idx+half_group_size), column)).rg;
            }
            else {
                elemk = imageLoad(pingpong0, ivec2(idx, column)).rg;
                elemks = imageLoad(pingpong0, ivec2(idx+half_group_size, column)).rg;
            }
            // Write result
            result = elemk + complex_mult(w, elemks);
            imageStore(pingpong1, ivec2(idx, column), vec4(result,0,0));
        }
    }
    else {
        vec2 result;
        if((idx % group_size) >= half_group_size) {
            if(stage == 0) {
                // when stage = 0 use bit reverse indices
                elemk = imageLoad(pingpong1, ivec2(bit_reverse(idx), column)).rg;
                elemks = imageLoad(pingpong1, ivec2(bit_reverse(idx-half_group_size), column)).rg;
            }
            else {
                elemk = imageLoad(pingpong1, ivec2(idx, column)).rg;
                elemks = imageLoad(pingpong1, ivec2(idx-half_group_size, column)).rg;
            }
            result = elemks - complex_mult(w, elemk);
            imageStore(pingpong0, ivec2(idx, column), vec4(result,0,0));
        }
        else {
            if(stage == 0) {
                // when stage = 0 use bit reverse indices
                elemk = imageLoad(pingpong1, ivec2(bit_reverse(idx), column)).rg;
                elemks = imageLoad(pingpong1, ivec2(bit_reverse(idx+half_group_size), column)).rg;
            }
            else {
                elemk = imageLoad(pingpong1, ivec2(idx, column)).rg;
                elemks = imageLoad(pingpong1, ivec2(idx+half_group_size, column)).rg;
            }
            // Write result
            result = elemk + complex_mult(w, elemks);
            imageStore(pingpong0, ivec2(idx, column), vec4(result,0,0));
        }
    }
}