#version 430

#define M_PI 3.1415926535897932384626433832795

layout (local_size_x = 8, local_size_y = 8) in;

// ping pong textures
layout (binding = 0, rg32f) uniform image2D pingpong0;
layout (binding = 1, rg32f) uniform image2D pingpong1;

uniform int pingpong;
uniform int log_width;
uniform int stage;
uniform int fft_dir;

// Constants
int vals_per_processors = 256 / 32;
int iter = 1 << log_width;
int shift = (1 << stage);

vec2 complex_mult(vec2 v0, vec2 v1) {
    return vec2(
        v0.x * v1.x - v0.y * v1.y,
        v0.x * v1.y + v0.y * v1.x
    );
}

int bit_reverse(int k) {
    uint x = uint(k);
    uint n = 0;
    uint mask = 0x1;
    for (int i = 0; i < log_width; ++i) {
        n <<= 1;
        n |= (x & 1);
        x >>= 1;
    }
    return int(n);
}

vec2 euler(float angle) {
    return vec2(cos(angle), sin(angle));
}

void main() {
    uint iter_column = gl_GlobalInvocationID.x;
    uint iter_line = gl_GlobalInvocationID.y;

    int group_size = 2 << stage; //2 * iter / groups;
    int half_group_size = group_size >> 1;
    int idx = int(iter_line);

    // Compute the twiddle factor
    vec2 w = euler(fft_dir * 2 * (M_PI / group_size) * (int(iter_line) % half_group_size));

    vec2 elemk, elemks;
    
    // Multiply factor to divide the result by 256
    float mult_factor = 1.0;
    if ((stage == log_width - 1) && fft_dir == 1) {
        mult_factor = 1.0/(256.0*256.0);
    }

    // alternate between textures
    if(pingpong == 0)
    {
        vec2 result;
        if((idx % group_size) >= half_group_size) {
            if(stage == 0) {
                // when stage = 0 use bit reverse indices
                elemk = imageLoad(pingpong0, ivec2(iter_column, bit_reverse(idx))).rg;
                elemks = imageLoad(pingpong0, ivec2(iter_column, bit_reverse(idx-half_group_size))).rg;
            }
            else {
                elemk = imageLoad(pingpong0, ivec2(iter_column, idx)).rg;
                elemks = imageLoad(pingpong0, ivec2(iter_column, idx-half_group_size)).rg;
            }
            result = (elemks - complex_mult(w, elemk)) * mult_factor;
            imageStore(pingpong1, ivec2(iter_column, idx), vec4(result,0,0));
        }
        else {
            if(stage == 0) {
                // when stage = 0 use bit reverse indices
                elemk = imageLoad(pingpong0, ivec2(iter_column, bit_reverse(idx))).rg;
                elemks = imageLoad(pingpong0, ivec2(iter_column, bit_reverse(idx+half_group_size))).rg;
            }
            else {
                elemk = imageLoad(pingpong0, ivec2(iter_column, idx)).rg;
                elemks = imageLoad(pingpong0, ivec2(iter_column, idx+half_group_size)).rg;
            }
            // Write result
            result = (elemk + complex_mult(w, elemks)) * mult_factor;
            imageStore(pingpong1, ivec2(iter_column, idx), vec4(result,0,0));
        }
    }
    else {
        vec2 result;
        if((idx % group_size) >= half_group_size) {
            if(stage == 0) {
                // when stage = 0 use bit reverse indices
                elemk = imageLoad(pingpong1, ivec2(iter_column, bit_reverse(idx))).rg;
                elemks = imageLoad(pingpong1, ivec2(iter_column, bit_reverse(idx-half_group_size))).rg;
            }
            else {
                elemk = imageLoad(pingpong1, ivec2(iter_column, idx)).rg;
                elemks = imageLoad(pingpong1, ivec2(iter_column, idx-half_group_size)).rg;
            }
            result = (elemks - complex_mult(w, elemk)) * mult_factor;
            imageStore(pingpong1, ivec2(iter_column, idx), vec4(result,0,0));
        }
        else {
            if(stage == 0) {
                // when stage = 0 use bit reverse indices
                elemk = imageLoad(pingpong1, ivec2(iter_column, bit_reverse(idx))).rg;
                elemks = imageLoad(pingpong1, ivec2(iter_column, bit_reverse(idx+half_group_size))).rg;
            }
            else {
                elemk = imageLoad(pingpong1, ivec2(iter_column, idx)).rg;
                elemks = imageLoad(pingpong1, ivec2(iter_column, idx+half_group_size)).rg;
            }
            // Write result
            result = (elemk + complex_mult(w, elemks)) * mult_factor;
            imageStore(pingpong0, ivec2(iter_column, idx), vec4(result,0,0));
        }
    }
}

