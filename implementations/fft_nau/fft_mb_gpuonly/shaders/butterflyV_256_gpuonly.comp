#version 440

#define M_PI 3.1415926535897932384626433832795
#define NUM_BUTTERFLIES 2
#define FFT_SIZE 256
#define LOG_SIZE 8 // log2(FFT_SIZE)

layout (local_size_x = (FFT_SIZE/2)/NUM_BUTTERFLIES, local_size_y = 1) in;

// ping pong textures
layout (binding = 0, rg32f) uniform image2D pingpong0;
layout (binding = 1, rg32f) uniform image2D pingpong1;

uniform int log_width;
uniform int fft_dir;

vec2 complex_mult(vec2 v0, vec2 v1) {
	return vec2(v0.x * v1.x - v0.y * v1.y,
				v0.x * v1.y + v0.y * v1.x);
}


int bit_reverse(int k) {
    // // No bit reversal
    // return 1;

    // Integrated bit reversal
    uint br = bitfieldReverse(k);
    return int(bitfieldExtract(br, 32 - LOG_SIZE, LOG_SIZE));

    // // Homemade bit reversal algorithm
    // uint x = uint(k);
    // uint n = 0;
    // uint mask = 0x1;
    // for (int i = 0; i < LOG_SIZE; ++i) {
    //     n <<= 1;
    //     n |= (x & 1);
    //     x >>= 1;
    // }
    // return int(n);
}


vec2 euler(float angle) {
	return vec2(cos(angle), sin(angle));
}


void main() {
    // FIXME: This variables are working but not correct, to be able to change
	int line = int(gl_WorkGroupID.y);
	int column = int(gl_GlobalInvocationID.x);
    int pingpong = 0;

    for(int stage = 0; stage < LOG_SIZE; ++stage) {
        // Each iteration on this loop corresponds
        // to a stage iteration on each reserved positions
        // for this thread

        // 1. Compute Butterflies
        int group_size = 2 << stage;
        int shift = 1 << stage;
        
        vec2 elemk, elemks;
        for(int i = 0; i < NUM_BUTTERFLIES; ++i) {
            // Compute the virtual index of the number of the
            // butterfly we're about to compute.
            int id = (column*NUM_BUTTERFLIES + i);
            // Compute the idx of the place we're working on now
            int idx = (id % shift) + group_size * (id / shift);
            // Compute the twiddle factor
            vec2 w = euler(fft_dir * 2 * (M_PI / group_size) * ((idx % group_size) % shift));

            // If its last stage the mult_factor will divide
            // every value by N, the size of the texture (256).
            float mult_factor = 1.0;
            if ((stage == LOG_SIZE - 1) && fft_dir == 1) {
                mult_factor = 1.0 / (FFT_SIZE*FFT_SIZE) ;
            }

            // alternate between textures
            if (pingpong == 0) {
                // when stage = 0 use bit reverse indices
                if (stage == 0) {
                    elemk = imageLoad(pingpong0, ivec2(line, bit_reverse(idx))).rg;
                    elemks = imageLoad(pingpong0, ivec2(line, bit_reverse(idx + shift))).rg;
                }
                else {
                    elemk = imageLoad(pingpong0, ivec2(line, idx)).rg;
                    elemks = imageLoad(pingpong0, ivec2(line, idx + shift)).rg;
                }
                
                    
                // write the outputs
                vec2 raux = (elemk + complex_mult(w, elemks)) * mult_factor;
                imageStore(pingpong1, ivec2(line, idx), vec4(raux,0,0));
                // NOTE: Debug
                // imageStore(pingpong1, ivec2(line, idx), vec4(0,0,0,0));
                    
                raux = (elemk - complex_mult(w, elemks)) * mult_factor;
                imageStore(pingpong1, ivec2(line, idx + shift), vec4(raux,0,0));
                // NOTE: Debug
                // imageStore(pingpong1, ivec2(line, idx + shift), vec4(0,0,0,0));

            }
            else {
                if (stage == 0) {
                    elemk = imageLoad(pingpong1, ivec2(line, bit_reverse(idx))).rg;
                    elemks = imageLoad(pingpong1, ivec2(line, bit_reverse(idx + shift))).rg;
                }
                else {	
                    elemk = imageLoad(pingpong1, ivec2(line, idx)).rg;
                    elemks = imageLoad(pingpong1, ivec2(line, idx + shift)).rg;
                }

                vec2 raux = (elemk + complex_mult(w, elemks)) * mult_factor;
                imageStore(pingpong0, ivec2(line, idx), vec4(raux,0,0));
                // NOTE: Debug
                // imageStore(pingpong0, ivec2(line, idx), vec4(0,0,0,0));
                    
                raux = (elemk - complex_mult(w, elemks)) * mult_factor;
                imageStore(pingpong0, ivec2(line, idx + shift), vec4(raux,0,0));
                // NOTE: Debug
                // imageStore(pingpong0, ivec2(line, idx + shift), vec4(0,0,0,0));
            }
        }
        
        // 2. Update Variables
        pingpong = ((pingpong + 1) % 2);

        // 3. Sync by Barrier
        barrier();
    }
    

}